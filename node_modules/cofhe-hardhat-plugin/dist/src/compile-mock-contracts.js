"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileMockContractPaths = void 0;
const fs_1 = __importDefault(require("fs"));
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const path_1 = __importDefault(require("path"));
const paths = [
    "@fhenixprotocol/cofhe-mock-contracts/ACL.sol",
    "@fhenixprotocol/cofhe-mock-contracts/MockCoFHE.sol",
    "@fhenixprotocol/cofhe-mock-contracts/MockQueryDecrypter.sol",
    "@fhenixprotocol/cofhe-mock-contracts/MockTaskManager.sol",
    "@fhenixprotocol/cofhe-mock-contracts/MockZkVerifier.sol",
    "@fhenixprotocol/cofhe-mock-contracts/TestBed.sol",
];
const pluginName = "cofhe-mock-contracts";
const generate = function (dependency) {
    return [
        "// SPDX-License-Identifier: UNLICENSED",
        "pragma solidity >0.0.0;",
        `import '${dependency}';`,
    ]
        .map((l) => `${l}\n`)
        .join("");
};
const compileMockContractPaths = async (hre) => {
    // other packages may incorrectly set a relative sources path so it must be explicitly resolved
    const sources = path_1.default.resolve(hre.config.paths.sources);
    const directory = path_1.default.resolve(sources, pluginName);
    const tracker = path_1.default.resolve(directory, `.${pluginName}`);
    if (!fs_1.default.existsSync(sources)) {
        fs_1.default.mkdirSync(sources);
    }
    if (!directory.startsWith(sources)) {
        throw new plugins_1.HardhatPluginError(pluginName, "resolved path must be inside of sources directory");
    }
    if (directory === sources) {
        throw new plugins_1.HardhatPluginError(pluginName, "resolved path must not be sources directory");
    }
    if (fs_1.default.existsSync(directory)) {
        // delete directory only if tracker is found or directory is empty
        if (fs_1.default.existsSync(tracker) || fs_1.default.readdirSync(directory).length === 0) {
            fs_1.default.rmSync(directory, { recursive: true });
        }
        else {
            throw new plugins_1.HardhatPluginError(pluginName, `temporary source directory must have been generated by ${pluginName}`);
        }
    }
    fs_1.default.mkdirSync(directory);
    fs_1.default.writeFileSync(tracker, `directory approved for write access by ${pluginName}\n`);
    for (const dependency of paths) {
        const fullPath = path_1.default.join(directory, dependency);
        if (!fs_1.default.existsSync(path_1.default.dirname(fullPath))) {
            fs_1.default.mkdirSync(path_1.default.dirname(fullPath), { recursive: true });
        }
        fs_1.default.writeFileSync(fullPath, generate(dependency));
    }
    try {
        await hre.run("compile:silent");
    }
    finally {
        fs_1.default.rmSync(directory, { recursive: true });
    }
};
exports.compileMockContractPaths = compileMockContractPaths;
// Override the compile:silent task to filter out warning logs
(0, config_1.task)("compile:silent", "Compiles without printing warnings").setAction(async (args, hre, runSuper) => {
    // Store original console methods
    const originalLog = console.log;
    const originalWarn = console.warn;
    const originalError = console.error;
    // Override console methods to filter warnings
    console.log = (...args) => {
        const logString = args.join(" ");
        if (!logString.includes("Warning")) {
            originalLog.apply(console, args);
        }
    };
    console.warn = (...args) => {
        const logString = args.join(" ");
        if (!logString.includes("Warning")) {
            originalWarn.apply(console, args);
        }
    };
    console.error = (...args) => {
        const logString = args.join(" ");
        if (!logString.includes("Warning")) {
            originalError.apply(console, args);
        }
    };
    try {
        // Run the original compile task
        await hre.run("compile");
    }
    finally {
        // Restore original console methods
        console.log = originalLog;
        console.warn = originalWarn;
        console.error = originalError;
    }
});
//# sourceMappingURL=compile-mock-contracts.js.map