"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployMocks = void 0;
const utils_1 = require("./utils");
const addresses_1 = require("./addresses");
const compile_mock_contracts_1 = require("./compile-mock-contracts");
const chalk_1 = __importDefault(require("chalk"));
const const_1 = require("./const");
// Deploy
const deployMockTaskManager = async (hre) => {
    const [signer] = await hre.ethers.getSigners();
    // Deploy MockTaskManager
    const TaskManagerArtifact = await hre.artifacts.readArtifact("TaskManager");
    await (0, utils_1.hardhatSetCode)(hre, addresses_1.TASK_MANAGER_ADDRESS, TaskManagerArtifact.deployedBytecode);
    const taskManager = await hre.ethers.getContractAt("TaskManager", addresses_1.TASK_MANAGER_ADDRESS);
    // Initialize MockTaskManager
    const initTx = await taskManager.initialize(signer.address);
    await initTx.wait();
    // Check if MockTaskManager exists
    const tmExists = await taskManager.exists();
    if (!tmExists) {
        throw new Error("MockTaskManager does not exist");
    }
    return taskManager;
};
const deployMockACL = async (hre) => {
    // Get Signer
    const [signer] = await hre.ethers.getSigners();
    // Deploy ACL implementation
    const aclFactory = await hre.ethers.getContractFactory("ACL");
    const acl = await aclFactory.deploy(signer.address);
    await acl.waitForDeployment();
    // Check if ACL exists
    const exists = await acl.exists();
    if (!exists) {
        (0, utils_1.logError)("ACL does not exist", 2);
        throw new Error("ACL does not exist");
    }
    return acl;
};
const deployMockZkVerifier = async (hre) => {
    const zkVerifierArtifact = await hre.artifacts.readArtifact("MockZkVerifier");
    await (0, utils_1.hardhatSetCode)(hre, addresses_1.ZK_VERIFIER_ADDRESS, zkVerifierArtifact.deployedBytecode);
    const zkVerifier = await hre.ethers.getContractAt("MockZkVerifier", addresses_1.ZK_VERIFIER_ADDRESS);
    const zkVerifierExists = await zkVerifier.exists();
    if (!zkVerifierExists) {
        (0, utils_1.logError)("MockZkVerifier does not exist", 2);
        throw new Error("MockZkVerifier does not exist");
    }
    return zkVerifier;
};
const deployMockQueryDecrypter = async (hre, acl) => {
    const queryDecrypterArtifact = await hre.artifacts.readArtifact("MockQueryDecrypter");
    await (0, utils_1.hardhatSetCode)(hre, addresses_1.QUERY_DECRYPTER_ADDRESS, queryDecrypterArtifact.deployedBytecode);
    const queryDecrypter = await hre.ethers.getContractAt("MockQueryDecrypter", addresses_1.QUERY_DECRYPTER_ADDRESS);
    // Initialize MockQueryDecrypter
    const initTx = await queryDecrypter.initialize(addresses_1.TASK_MANAGER_ADDRESS, await acl.getAddress());
    await initTx.wait();
    // Check if MockQueryDecrypter exists
    const queryDecrypterExists = await queryDecrypter.exists();
    if (!queryDecrypterExists) {
        (0, utils_1.logError)("MockQueryDecrypter does not exist", 2);
        throw new Error("MockQueryDecrypter does not exist");
    }
    return queryDecrypter;
};
const deployTestBedContract = async (hre) => {
    const testBedFactory = await hre.artifacts.readArtifact("TestBed");
    await (0, utils_1.hardhatSetCode)(hre, addresses_1.TEST_BED_ADDRESS, testBedFactory.deployedBytecode);
    const testBed = await hre.ethers.getContractAt("TestBed", addresses_1.TEST_BED_ADDRESS);
    await testBed.waitForDeployment();
    return testBed;
};
// Funding
const fundZkVerifierSigner = async (hre) => {
    const zkVerifierSigner = await hre.ethers.getSigner(const_1.MOCK_ZK_VERIFIER_SIGNER_ADDRESS);
    await hre.network.provider.send("hardhat_setBalance", [
        zkVerifierSigner.address,
        "0x" + hre.ethers.parseEther("10").toString(16),
    ]);
};
// Initializations
const setTaskManagerACL = async (taskManager, acl) => {
    const setAclTx = await taskManager.setACLContract(await acl.getAddress());
    await setAclTx.wait();
};
const deployMocks = async (hre, options = {
    deployTestBed: true,
    gasWarning: true,
    silent: false,
}) => {
    // Check if network is Hardhat, if not log skip message and return
    const isHardhat = await (0, utils_1.checkNetworkAndSkip)(hre);
    if (!isHardhat)
        return;
    const logEmptyIfNoisy = () => {
        if (!options.silent) {
            (0, utils_1.logEmpty)();
        }
    };
    const logSuccessIfNoisy = (message, indent = 0) => {
        if (!options.silent) {
            (0, utils_1.logSuccess)(message, indent);
        }
    };
    const logDeploymentIfNoisy = (contractName, address) => {
        if (!options.silent) {
            (0, utils_1.logDeployment)(contractName, address);
        }
    };
    const logWarningIfNoisy = (message, indent = 0) => {
        if (!options.silent) {
            (0, utils_1.logWarning)(message, indent);
        }
    };
    // Log start message
    logEmptyIfNoisy();
    logSuccessIfNoisy(chalk_1.default.bold("cofhe-hardhat-plugin :: deploy mocks"), 0);
    logEmptyIfNoisy();
    // Compile mock contracts
    await (0, compile_mock_contracts_1.compileMockContractPaths)(hre);
    logEmptyIfNoisy();
    logSuccessIfNoisy("Mock contracts compiled", 1);
    // Deploy mock contracts
    const taskManager = await deployMockTaskManager(hre);
    logDeploymentIfNoisy("MockTaskManager", await taskManager.getAddress());
    const acl = await deployMockACL(hre);
    logDeploymentIfNoisy("MockACL", await acl.getAddress());
    await setTaskManagerACL(taskManager, acl);
    logSuccessIfNoisy("ACL address set in TaskManager", 2);
    await fundZkVerifierSigner(hre);
    logSuccessIfNoisy(`ZkVerifier signer (${const_1.MOCK_ZK_VERIFIER_SIGNER_ADDRESS}) funded`, 1);
    const zkVerifierSignerBalance = await hre.ethers.provider.getBalance(const_1.MOCK_ZK_VERIFIER_SIGNER_ADDRESS);
    logSuccessIfNoisy(`ETH balance: ${zkVerifierSignerBalance.toString()}`, 2);
    const zkVerifier = await deployMockZkVerifier(hre);
    logDeploymentIfNoisy("MockZkVerifier", await zkVerifier.getAddress());
    const queryDecrypter = await deployMockQueryDecrypter(hre, acl);
    logDeploymentIfNoisy("MockQueryDecrypter", await queryDecrypter.getAddress());
    if (options.deployTestBed) {
        logSuccessIfNoisy("TestBed deployment enabled", 2);
        const testBed = await deployTestBedContract(hre);
        logDeploymentIfNoisy("TestBed", await testBed.getAddress());
    }
    // Log success message
    logEmptyIfNoisy();
    logSuccessIfNoisy(chalk_1.default.bold("cofhe-hardhat-plugin :: mocks deployed successfully"), 0);
    // Log warning about mocks increased gas costs
    if (options.gasWarning) {
        logEmptyIfNoisy();
        logWarningIfNoisy("When using mocks, FHE operations (eg FHE.add / FHE.mul) report a higher gas price due to additional on-chain mocking logic. Deploy your contracts on a testnet chain to check the true gas costs.\n(Disable this warning by setting 'cofhejs.gasWarning' to false in your hardhat config", 0);
    }
    logEmptyIfNoisy();
};
exports.deployMocks = deployMocks;
//# sourceMappingURL=deploy-mocks.js.map