import { DeployMocksArgs } from "./deploy-mocks";
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";
import { HHSignerInitializationParams } from "./networkUtils";
import { Permit, Result } from "cofhejs/node";
/**
 * Configuration interface for the CoFHE Hardhat plugin.
 * Allows users to configure mock logging and gas warning settings.
 */
declare module "hardhat/types/config" {
    interface HardhatUserConfig {
        cofhe?: {
            /** Whether to log mock operations (default: true) */
            logMocks?: boolean;
            /** Whether to show gas usage warnings for mock operations (default: true) */
            gasWarning?: boolean;
        };
    }
    interface HardhatConfig {
        cofhe: {
            logMocks: boolean;
            gasWarning: boolean;
        };
    }
}
export * from "./mockUtils";
export * from "./networkUtils";
export * from "./result";
export * from "./common";
export * from "./mock-logs";
export * from "./deploy-mocks";
/**
 * Runtime environment extensions for the CoFHE Hardhat plugin.
 * Provides access to CoFHE initialization, environment checks, and mock utilities.
 */
declare module "hardhat/types/runtime" {
    interface HardhatRuntimeEnvironment {
        cofhe: {
            /**
             * Initialize `cofhejs` using a Hardhat signer
             * @param {HardhatEthersSigner} signer - The Hardhat ethers signer to use
             * @param {HHSignerInitializationParams} params - Optional initialization parameters to be passed to `cofhejs`
             * @returns {Promise<Result<Permit | undefined>>} The initialized CoFHE instance
             */
            initializeWithHardhatSigner: (signer: HardhatEthersSigner, params?: HHSignerInitializationParams) => Promise<Result<Permit | undefined>>;
            /**
             * Check if a CoFHE environment is permitted for the current network
             * @param {string} env - The environment name to check. Must be "MOCK" | "LOCAL" | "TESTNET" | "MAINNET"
             * @returns {boolean} Whether the environment is permitted
             */
            isPermittedEnvironment: (env: string) => boolean;
            /**
             * Assert that a Result type (see cofhejs) returned from a function is successful and return its value
             * @param {Result<T>} result - The Result to check
             * @returns {T} The inner data of the Result (non null)
             */
            expectResultSuccess: <T>(result: Result<T> | Promise<Result<T>>) => Promise<T>;
            /**
             * Assert that a Result type (see cofhejs) contains an error matching the partial string
             * @param {Result<T>} result - The Result to check
             * @param {string} errorPartial - The partial error string to match
             */
            expectResultError: <T>(result: Result<T> | Promise<Result<T>>, errorPartial: string) => Promise<void>;
            /**
             * Assert that a Result type (see cofhejs) contains a specific value
             * @param {Result<T>} result - The Result to check
             * @param {T} value - The inner data of the Result (non null)
             */
            expectResultValue: <T>(result: Result<T> | Promise<Result<T>>, value: T) => Promise<T>;
            /**
             * Assert that a Result type (see cofhejs) contains a value matching the partial object
             * @param {Result<T>} result - The Result to check
             * @param {Partial<T>} partial - The partial object to match against
             * @returns {T} The inner data of the Result (non null)
             */
            expectResultPartialValue: <T>(result: Result<T> | Promise<Result<T>>, partial: Partial<T>) => Promise<T>;
            mocks: {
                /**
                 * **[MOCKS ONLY]**
                 *
                 * Execute a block of code with cofhe mock contracts logging enabled.
                 *
                 * _(If logging only a function, we recommend passing the function name as the closureName (ex "counter.increment()"))_
                 *
                 * Expected output:
                 * ```
                 * ┌──────────────────┬──────────────────────────────────────────────────
                 * │ [COFHE-MOCKS]    │ "counter.increment()" logs:
                 * ├──────────────────┴──────────────────────────────────────────────────
                 * ├ FHE.add          | euint32(4473..3424)[0] + euint32(1157..3648)[1]  =>  euint32(1106..1872)[1]
                 * ├ FHE.allowThis    | euint32(1106..1872)[1] -> 0x663f..6602
                 * ├ FHE.allow        | euint32(1106..1872)[1] -> 0x3c44..93bc
                 * └─────────────────────────────────────────────────────────────────────
                 * ```
                 * @param {string} closureName - Name of the code block to log within
                 * @param {() => Promise<void>} closure - The async function to execute
                 */
                withLogs: (closureName: string, closure: () => Promise<void>) => Promise<void>;
                /**
                 * **[MOCKS ONLY]**
                 *
                 * Enable logging from cofhe mock contracts
                 * @param {string} closureName - Optional name of the code block to enable logging for
                 */
                enableLogs: (closureName?: string) => Promise<void>;
                /**
                 * **[MOCKS ONLY]**
                 *
                 * Disable logging from cofhe mock contracts
                 */
                disableLogs: () => Promise<void>;
                /**
                 * **[MOCKS ONLY]**
                 *
                 * Deploy the cofhe mock contracts (normally this is done automatically)
                 * @param {DeployMocksArgs} options - Deployment options
                 */
                deployMocks: (options: DeployMocksArgs) => Promise<void>;
                /**
                 * **[MOCKS ONLY]**
                 *
                 * Get the plaintext value for a ciphertext hash
                 * @param {bigint} ctHash - The ciphertext hash to look up
                 * @returns {Promise<bigint>} The plaintext value
                 */
                getPlaintext: (ctHash: bigint) => Promise<bigint>;
                /**
                 * **[MOCKS ONLY]**
                 *
                 * Assert that a ciphertext hash represents an expected plaintext value
                 * @param {bigint} ctHash - The ciphertext hash to check
                 * @param {bigint} expectedValue - The expected plaintext value
                 */
                expectPlaintext: (ctHash: bigint, expectedValue: bigint) => Promise<void>;
            };
        };
    }
}
//# sourceMappingURL=index.d.ts.map