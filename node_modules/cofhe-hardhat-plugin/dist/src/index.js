"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const config_1 = require("hardhat/config");
const common_1 = require("./common");
const const_1 = require("./const");
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const deploy_mocks_1 = require("./deploy-mocks");
const mock_logs_1 = require("./mock-logs");
const mockUtils_1 = require("./mockUtils");
const mockUtils_2 = require("./mockUtils");
const networkUtils_1 = require("./networkUtils");
const result_1 = require("./result");
(0, config_1.extendConfig)((config, userConfig) => {
    // Allow users to override the localcofhe network config
    if (userConfig.networks && userConfig.networks.localcofhe) {
        return;
    }
    // Default config
    config.networks.localcofhe = {
        gas: "auto",
        gasMultiplier: 1.2,
        gasPrice: "auto",
        timeout: 10000,
        httpHeaders: {},
        url: "http://127.0.0.1:42069",
        accounts: [
            "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
            "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d",
            "0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a",
            "0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6",
        ],
    };
    // Only add Sepolia config if user hasn't defined it
    if (!userConfig.networks?.["eth-sepolia"]) {
        config.networks["eth-sepolia"] = {
            url: process.env.SEPOLIA_RPC_URL ||
                "https://ethereum-sepolia.publicnode.com",
            accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
            chainId: 11155111,
            gas: "auto",
            gasMultiplier: 1.2,
            gasPrice: "auto",
            timeout: 60000,
            httpHeaders: {},
        };
    }
    // Only add Arbitrum Sepolia config if user hasn't defined it
    if (!userConfig.networks?.["arb-sepolia"]) {
        config.networks["arb-sepolia"] = {
            url: process.env.ARBITRUM_SEPOLIA_RPC_URL ||
                "https://sepolia-rollup.arbitrum.io/rpc",
            accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
            chainId: 421614,
            gas: "auto",
            gasMultiplier: 1.2,
            gasPrice: "auto",
            timeout: 60000,
            httpHeaders: {},
        };
    }
    // Add cofhe config
    config.cofhe = {
        logMocks: userConfig.cofhe?.logMocks ?? true,
        gasWarning: userConfig.cofhe?.gasWarning ?? true,
    };
});
(0, config_1.task)(const_1.TASK_COFHE_USE_FAUCET, "Fund an account from the funder")
    .addOptionalParam("address", "Address to fund", undefined, config_1.types.string)
    .setAction(async ({ address }, hre) => {
    const { network } = hre;
    const { name: networkName } = network;
    if (networkName !== "localcofhe") {
        console.info(chalk_1.default.yellow(`Programmatic faucet only supported for localcofhe`));
        return;
    }
    if (!address) {
        console.info(chalk_1.default.red(`Failed to get address to fund`));
        return;
    }
    console.info(chalk_1.default.green(`Getting funds from faucet for ${address}`));
    try {
        await (0, common_1.localcofheFundAccount)(hre, address);
    }
    catch (e) {
        console.info(chalk_1.default.red(`failed to get funds from localcofhe for ${address}: ${e}`));
    }
});
// DEPLOY TASKS
(0, config_1.task)(const_1.TASK_COFHE_MOCKS_DEPLOY, "Deploys the mock contracts on the Hardhat network")
    .addOptionalParam("deployTestBed", "Whether to deploy the test bed", true, config_1.types.boolean)
    .addOptionalParam("silent", "Whether to suppress output", false, config_1.types.boolean)
    .setAction(async ({ deployTestBed, silent }, hre) => {
    await (0, deploy_mocks_1.deployMocks)(hre, {
        deployTestBed: deployTestBed ?? true,
        gasWarning: hre.config.cofhe.gasWarning ?? true,
        silent: silent ?? false,
    });
});
(0, config_1.task)(task_names_1.TASK_TEST, "Deploy mock contracts on hardhat").setAction(async ({}, hre, runSuper) => {
    await (0, deploy_mocks_1.deployMocks)(hre, {
        deployTestBed: true,
        gasWarning: hre.config.cofhe.gasWarning ?? true,
    });
    return runSuper();
});
(0, config_1.task)(task_names_1.TASK_NODE, "Deploy mock contracts on hardhat").setAction(async ({}, hre, runSuper) => {
    await (0, deploy_mocks_1.deployMocks)(hre, {
        deployTestBed: true,
        gasWarning: hre.config.cofhe.gasWarning ?? true,
    });
    return runSuper();
});
// SET LOG OPS
(0, config_1.task)(const_1.TASK_COFHE_MOCKS_SET_LOG_OPS, "Set logging for the Mock CoFHE contracts")
    .addParam("enable", "Whether to enable logging", false, config_1.types.boolean)
    .setAction(async ({ enable }, hre) => {
    await (0, mock_logs_1.mock_setLoggingEnabled)(hre, enable);
});
// MOCK UTILS
__exportStar(require("./mockUtils"), exports);
__exportStar(require("./networkUtils"), exports);
__exportStar(require("./result"), exports);
__exportStar(require("./common"), exports);
__exportStar(require("./mock-logs"), exports);
__exportStar(require("./deploy-mocks"), exports);
(0, config_1.extendConfig)((config) => {
    config.cofhe = config.cofhe || {};
});
(0, config_1.extendEnvironment)((hre) => {
    hre.cofhe = {
        initializeWithHardhatSigner: async (signer, params) => {
            return (0, networkUtils_1.cofhejs_initializeWithHardhatSigner)(hre, signer, params);
        },
        isPermittedEnvironment: (env) => {
            return (0, networkUtils_1.isPermittedCofheEnvironment)(hre, env);
        },
        expectResultSuccess: async (result) => {
            const awaitedResult = await result;
            return (0, result_1.expectResultSuccess)(awaitedResult);
        },
        expectResultError: async (result, errorPartial) => {
            const awaitedResult = await result;
            return (0, result_1.expectResultError)(awaitedResult, errorPartial);
        },
        expectResultValue: async (result, value) => {
            const awaitedResult = await result;
            return (0, result_1.expectResultValue)(awaitedResult, value);
        },
        expectResultPartialValue: async (result, partial) => {
            const awaitedResult = await result;
            return (0, result_1.expectResultPartialValue)(awaitedResult, partial);
        },
        mocks: {
            withLogs: async (closureName, closure) => {
                return (0, mock_logs_1.mock_withLogs)(hre, closureName, closure);
            },
            enableLogs: async (closureName) => {
                return (0, mock_logs_1.mock_setLoggingEnabled)(hre, true, closureName);
            },
            disableLogs: async () => {
                return (0, mock_logs_1.mock_setLoggingEnabled)(hre, false);
            },
            deployMocks: async (options) => {
                return (0, deploy_mocks_1.deployMocks)(hre, options);
            },
            getPlaintext: async (ctHash) => {
                const [signer] = await hre.ethers.getSigners();
                return (0, mockUtils_2.mock_getPlaintext)(signer.provider, ctHash);
            },
            expectPlaintext: async (ctHash, expectedValue) => {
                const [signer] = await hre.ethers.getSigners();
                return (0, mockUtils_1.mock_expectPlaintext)(signer.provider, ctHash, expectedValue);
            },
        },
    };
});
//# sourceMappingURL=index.js.map