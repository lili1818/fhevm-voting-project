"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mock_expectPlaintext = exports.mock_getPlaintextExists = exports.mock_getPlaintext = void 0;
const addresses_1 = require("./addresses");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const mock_checkIsTestnet = async (fnName, provider) => {
    // Testnet is checked by testing if MockZkVerifier is deployed
    // Get bytecode at ZK_VERIFIER_ADDRESS
    const bytecode = await provider.getCode(addresses_1.ZK_VERIFIER_ADDRESS);
    // If bytecode is empty, we are on a testnet
    const isTestnet = bytecode.length === 0;
    // Log if we are on a testnet
    if (isTestnet) {
        console.log(`${fnName} - skipped on non-testnet chain`);
    }
    return isTestnet;
};
const mock_getPlaintext = async (provider, ctHash) => {
    // Skip with log if called on a non-testnet chain
    if (await mock_checkIsTestnet(exports.mock_getPlaintext.name, provider))
        return;
    // Connect to MockTaskManager
    const taskManager = new ethers_1.ethers.Contract(addresses_1.TASK_MANAGER_ADDRESS, ["function mockStorage(uint256) view returns (uint256)"], provider);
    // Fetch the plaintext
    const plaintext = await taskManager.mockStorage(ctHash);
    return plaintext;
};
exports.mock_getPlaintext = mock_getPlaintext;
const mock_getPlaintextExists = async (provider, ctHash) => {
    // Skip with log if called on a non-testnet chain
    if (await mock_checkIsTestnet(exports.mock_getPlaintextExists.name, provider))
        return;
    // Connect to MockTaskManager
    const taskManager = new ethers_1.ethers.Contract(addresses_1.TASK_MANAGER_ADDRESS, ["function inMockStorage(uint256) view returns (bool)"], provider);
    // Fetch the plaintext exists
    const plaintextExists = await taskManager.inMockStorage(ctHash);
    return plaintextExists;
};
exports.mock_getPlaintextExists = mock_getPlaintextExists;
const mock_expectPlaintext = async (provider, ctHash, expectedValue) => {
    // Skip with log if called on a non-testnet chain
    if (await mock_checkIsTestnet(exports.mock_expectPlaintext.name, provider))
        return;
    // Expect the plaintext to exist
    const plaintextExists = await (0, exports.mock_getPlaintextExists)(provider, ctHash);
    (0, chai_1.expect)(plaintextExists).equal(true, "Plaintext does not exist");
    // Expect the plaintext to have the expected value
    const plaintext = await (0, exports.mock_getPlaintext)(provider, ctHash);
    (0, chai_1.expect)(plaintext).equal(expectedValue, "Plaintext value is incorrect");
};
exports.mock_expectPlaintext = mock_expectPlaintext;
//# sourceMappingURL=mockUtils.js.map