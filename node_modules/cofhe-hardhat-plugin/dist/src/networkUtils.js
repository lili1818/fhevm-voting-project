"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cofhejs_initializeWithHardhatSigner = exports.isPermittedCofheEnvironment = exports.getCofheEnvironmentFromNetwork = void 0;
const node_1 = require("cofhejs/node");
const const_1 = require("./const");
const getCofheEnvironmentFromNetwork = (network) => {
    switch (network) {
        case "localcofhe":
            return "LOCAL";
        case "hardhat":
        case "localhost":
            return "MOCK";
        case "arb-sepolia":
        case "eth-sepolia":
            return "TESTNET";
        default:
            throw new Error(`Unsupported network: ${network}`);
    }
};
exports.getCofheEnvironmentFromNetwork = getCofheEnvironmentFromNetwork;
const isPermittedCofheEnvironment = (hre, env) => {
    switch (env) {
        case "LOCAL":
            return ["localcofhe"].includes(hre.network.name);
        case "MOCK":
            return ["hardhat", "localhost"].includes(hre.network.name);
        case "TESTNET":
            return ["arb-sepolia", "eth-sepolia"].includes(hre.network.name);
        default:
            return false;
    }
};
exports.isPermittedCofheEnvironment = isPermittedCofheEnvironment;
const hhSignerToCofhejsProvider = (signer) => {
    const provider = {
        call: async (...args) => {
            try {
                return signer.provider.call(...args);
            }
            catch (e) {
                throw new Error(`cofhejs initializeWithHHSigner :: call :: ${e}`);
            }
        },
        getChainId: async () => (await signer.provider.getNetwork()).chainId.toString(),
        send: async (...args) => {
            try {
                return signer.provider.send(...args);
            }
            catch (e) {
                throw new Error(`cofhejs initializeWithHHSigner :: send :: ${e}`);
            }
        },
    };
    return provider;
};
const hhSignerToCofhejsSigner = (signer, provider) => {
    const abstractSigner = {
        signTypedData: async (domain, types, value) => signer.signTypedData(domain, types, value),
        getAddress: async () => signer.getAddress(),
        provider,
        sendTransaction: async (...args) => {
            try {
                const tx = await signer.sendTransaction(...args);
                return tx.hash;
            }
            catch (e) {
                throw new Error(`cofhejs initializeWithHHSigner :: sendTransaction :: ${e}`);
            }
        },
    };
    return abstractSigner;
};
const cofhejs_initializeWithHardhatSigner = async (hre, signer, params) => {
    const abstractProvider = hhSignerToCofhejsProvider(signer);
    const abstractSigner = hhSignerToCofhejsSigner(signer, abstractProvider);
    const zkvHhSigner = await hre.ethers.getImpersonatedSigner(const_1.MOCK_ZK_VERIFIER_SIGNER_ADDRESS);
    const zkvSigner = hhSignerToCofhejsSigner(zkvHhSigner, abstractProvider);
    return node_1.cofhejs.initialize({
        ...(params ?? {}),
        environment: params?.environment ??
            (0, exports.getCofheEnvironmentFromNetwork)((await signer.provider.getNetwork()).name),
        provider: abstractProvider,
        signer: abstractSigner,
        mockConfig: {
            zkvSigner,
        },
    });
};
exports.cofhejs_initializeWithHardhatSigner = cofhejs_initializeWithHardhatSigner;
//# sourceMappingURL=networkUtils.js.map