import { Primitive, LiteralToPrimitive } from 'type-fest';
import * as zustand_middleware from 'zustand/middleware';
import * as zustand_vanilla from 'zustand/vanilla';
import * as zod from 'zod';
import { z } from 'zod';
import { TfheClientKey, TfheCompactPublicKey } from 'tfhe';

type EthEncryptedData = {
    data: Uint8Array;
    public_key: Uint8Array;
    nonce: Uint8Array;
};
/**
 * A class representing a SealingKey which provides cryptographic sealing (encryption)
 * and unsealing (decryption) capabilities.
 */
declare class SealingKey {
    /**
     * The private key used for decryption.
     */
    privateKey: string;
    /**
     * The public key used for encryption.
     */
    publicKey: string;
    /**
     * Constructs a SealingKey instance with the given private and public keys.
     *
     * @param {string} privateKey - The private key used for decryption.
     * @param {string} publicKey - The public key used for encryption.
     * @throws Will throw an error if the provided keys lengths do not match
     *         the required lengths for private and public keys.
     */
    constructor(privateKey: string, publicKey: string);
    unseal: (parsedData: EthEncryptedData) => bigint;
    /**
     * Seals (encrypts) the provided message for a receiver with the specified public key.
     *
     * @param {bigint | number} value - The message to be encrypted.
     * @param {string} publicKey - The public key of the intended recipient.
     * @returns string - The encrypted message in hexadecimal format.
     * @static
     * @throws Will throw if the provided publicKey or value do not meet defined preconditions.
     */
    static seal: (value: bigint | number, publicKey: string) => EthEncryptedData;
}
/**
 * Asynchronously generates a new SealingKey.
 * This function uses the 'nacl' library to create a new public/private key pair for sealing purposes.
 * A sealing key is used to encrypt data such that it can only be unsealed (decrypted) by the owner of the corresponding private key.
 * @returns {Promise<SealingKey>} - A promise that resolves to a new SealingKey object containing the hexadecimal strings of the public and private keys.
 */
declare const GenerateSealingKey: () => Promise<SealingKey>;

declare enum FheTypes {
    Bool = 0,
    Uint4 = 1,
    Uint8 = 2,
    Uint16 = 3,
    Uint32 = 4,
    Uint64 = 5,
    Uint128 = 6,
    Uint160 = 7,
    Uint256 = 8,
    Uint512 = 9,
    Uint1024 = 10,
    Uint2048 = 11,
    Uint2 = 12,
    Uint6 = 13,
    Uint10 = 14,
    Uint12 = 15,
    Uint14 = 16,
    Int2 = 17,
    Int4 = 18,
    Int6 = 19,
    Int8 = 20,
    Int10 = 21,
    Int12 = 22,
    Int14 = 23,
    Int16 = 24,
    Int32 = 25,
    Int64 = 26,
    Int128 = 27,
    Int160 = 28,
    Int256 = 29
}
/**
 * List of All FHE uint types (excludes bool and address)
 */
declare const FheUintUTypes: readonly [FheTypes.Uint8, FheTypes.Uint16, FheTypes.Uint32, FheTypes.Uint64, FheTypes.Uint128, FheTypes.Uint256];
/**
 * List of All FHE types (uints, bool, and address)
 */
declare const FheAllUTypes: readonly [FheTypes.Bool, FheTypes.Uint8, FheTypes.Uint16, FheTypes.Uint32, FheTypes.Uint64, FheTypes.Uint128, FheTypes.Uint256, FheTypes.Uint160];

type EncryptedNumber = {
    data: Uint8Array;
    securityZone: number;
};
type CoFheInItem = {
    ctHash: bigint;
    securityZone: number;
    utype: FheTypes;
    signature: string;
};
type CoFheInBool = CoFheInItem & {
    utype: FheTypes.Bool;
};
type CoFheInUint8 = CoFheInItem & {
    utype: FheTypes.Uint8;
};
type CoFheInUint16 = CoFheInItem & {
    utype: FheTypes.Uint16;
};
type CoFheInUint32 = CoFheInItem & {
    utype: FheTypes.Uint32;
};
type CoFheInUint64 = CoFheInItem & {
    utype: FheTypes.Uint64;
};
type CoFheInUint128 = CoFheInItem & {
    utype: FheTypes.Uint128;
};
type CoFheInUint256 = CoFheInItem & {
    utype: FheTypes.Uint256;
};
type CoFheInAddress = CoFheInItem & {
    utype: FheTypes.Uint160;
};

type EncryptableBool = {
    data: boolean;
    utype: FheTypes.Bool;
};
type EncryptableUint8 = {
    data: string | bigint;
    utype: FheTypes.Uint8;
};
type EncryptableUint16 = {
    data: string | bigint;
    utype: FheTypes.Uint16;
};
type EncryptableUint32 = {
    data: string | bigint;
    utype: FheTypes.Uint32;
};
type EncryptableUint64 = {
    data: string | bigint;
    utype: FheTypes.Uint64;
};
type EncryptableUint128 = {
    data: string | bigint;
    utype: FheTypes.Uint128;
};
type EncryptableUint256 = {
    data: string | bigint;
    utype: FheTypes.Uint256;
};
type EncryptableAddress = {
    data: string | bigint;
    utype: FheTypes.Uint160;
};
declare const Encryptable: {
    readonly bool: (data: EncryptableBool["data"], securityZone?: number) => EncryptableBool;
    readonly address: (data: EncryptableAddress["data"], securityZone?: number) => EncryptableAddress;
    readonly uint8: (data: EncryptableUint8["data"], securityZone?: number) => EncryptableUint8;
    readonly uint16: (data: EncryptableUint16["data"], securityZone?: number) => EncryptableUint16;
    readonly uint32: (data: EncryptableUint32["data"], securityZone?: number) => EncryptableUint32;
    readonly uint64: (data: EncryptableUint64["data"], securityZone?: number) => EncryptableUint64;
    readonly uint128: (data: EncryptableUint128["data"], securityZone?: number) => EncryptableUint128;
    readonly uint256: (data: EncryptableUint256["data"], securityZone?: number) => EncryptableUint256;
};
type EncryptableItem = EncryptableBool | EncryptableUint8 | EncryptableUint16 | EncryptableUint32 | EncryptableUint64 | EncryptableUint128 | EncryptableUint256 | EncryptableAddress;
type Encryptable_CoFheInItem_Map<E extends EncryptableItem> = E extends EncryptableBool ? CoFheInBool : E extends EncryptableUint8 ? CoFheInUint8 : E extends EncryptableUint16 ? CoFheInUint16 : E extends EncryptableUint32 ? CoFheInUint32 : E extends EncryptableUint64 ? CoFheInUint64 : E extends EncryptableUint128 ? CoFheInUint128 : E extends EncryptableUint256 ? CoFheInUint256 : E extends EncryptableAddress ? CoFheInAddress : never;
type Encrypted_Inputs<T> = T extends Primitive ? LiteralToPrimitive<T> : T extends EncryptableItem ? Encryptable_CoFheInItem_Map<T> : {
    [K in keyof T]: Encrypted_Inputs<T[K]>;
};
declare function isEncryptableItem(value: any): value is EncryptableItem;
declare enum EncryptStep {
    Extract = "extract",
    Pack = "pack",
    Prove = "prove",
    Verify = "verify",
    Replace = "replace",
    Done = "done"
}
type EncryptSetStateFn = (state: EncryptStep) => void;

type EIP712Type = {
    name: string;
    type: string;
};
type EIP712Types = Record<string, EIP712Type[]>;
type EIP712Message = Record<string, string>;
type EIP712Domain = {
    chainId: number;
    name: string;
    verifyingContract: string;
    version: string;
};
type EIP712 = {
    domain: EIP712Domain;
    message: EIP712Message;
    primaryType: string;
    types: EIP712Types;
};

/**
 * Type representing the full Permit
 */
type PermitInterface = {
    /**
     * Name for this permit, for organization and UI usage, not included in signature.
     */
    name: string;
    /**
     * The type of the Permit (self / sharing)
     * (self) Permit that will be signed and used by the issuer
     * (sharing) Permit that is signed by the issuer, but intended to be shared with recipient
     * (recipient) Permit that has been received, and signed by the recipient
     */
    type: "self" | "sharing" | "recipient";
    /**
     * (base) User that initially created the permission, target of data fetching
     */
    issuer: string;
    /**
     * (base) Expiration timestamp
     */
    expiration: number;
    /**
     * (sharing) The user that this permission will be shared with
     * ** optional, use `address(0)` to disable **
     */
    recipient: string;
    /**
     * (issuer defined validation) An id used to query a contract to check this permissions validity
     * ** optional, use `0` to disable **
     */
    validatorId: number;
    /**
     * (issuer defined validation) The contract to query to determine permission validity
     * ** optional, user `address(0)` to disable **
     */
    validatorContract: string;
    /**
     * (base) The publicKey of a sealingPair used to re-encrypt `issuer`s confidential data
     *   (non-sharing) Populated by `issuer`
     *   (sharing)     Populated by `recipient`
     */
    sealingPair: SealingKey;
    /**
     * (base) `signTypedData` signature created by `issuer`.
     * (base) Shared- and Self- permissions differ in signature format: (`sealingKey` absent in shared signature)
     *   (non-sharing) < issuer, expiration, recipient, validatorId, validatorContract, sealingKey >
     *   (sharing)     < issuer, expiration, recipient, validatorId, validatorContract >
     */
    issuerSignature: string;
    /**
     * (sharing) `signTypedData` signature created by `recipient` with format:
     * (sharing) < sealingKey, issuerSignature>
     * ** required for shared permits **
     */
    recipientSignature: string;
};
/**
 * Optional additional metadata of a Permit
 * Can be passed into the constructor, but not necessary
 * Useful for deserialization
 */
type PermitMetadata = {
    /**
     * EIP712 domain used to sign this permit.
     * Should not be set manually, included in metadata as part of serialization flows.
     */
    _signedDomain: EIP712Domain | undefined;
};
type PickPartial<T, F extends keyof T> = Expand<Omit<T, F> & Partial<Pick<T, F>>>;
type PermitCore = Expand<Pick<PermitInterface, "issuer"> & Partial<Pick<PermitInterface, "recipient" | "validatorId" | "validatorContract">>>;
type PermitOptions = Expand<Partial<Omit<PermitInterface, "recipient" | "recipientSignature">> & {
    type: "self";
    issuer: string;
}> | Expand<Partial<Omit<PermitInterface, "recipientSignature">> & {
    type: "sharing";
    issuer: string;
    recipient: string;
}> | Expand<Partial<PermitInterface> & {
    type: "recipient";
    issuer: string;
    recipient: string;
    issuerSignature: string;
}>;
type SerializedPermit = Omit<PermitInterface, "sealingPair"> & {
    _signedDomain: EIP712Domain | undefined;
    sealingPair: {
        privateKey: string;
        publicKey: string;
    };
};
/**
 * A type representing the Permission struct that is passed to Permissioned.sol to grant encrypted data access.
 */
type Permission = Expand<Omit<PermitInterface, "name" | "type" | "sealingPair"> & {
    sealingKey: string;
}>;
type Expand<T> = T extends infer O ? {
    [K in keyof O]: O[K];
} : never;

declare enum CofhejsErrorCode {
    InternalError = "INTERNAL_ERROR",
    UnknownEnvironment = "UNKNOWN_ENVIRONMENT",
    InitTfheFailed = "INIT_TFHE_FAILED",
    InitViemFailed = "INIT_VIEM_FAILED",
    InitEthersFailed = "INIT_ETHERS_FAILED",
    NotInitialized = "NOT_INITIALIZED",
    MissingProviderParam = "MISSING_PROVIDER_PARAM",
    EmptySecurityZonesParam = "EMPTY_SECURITY_ZONES_PARAM",
    InvalidPermitData = "INVALID_PERMIT_DATA",
    InvalidPermitDomain = "INVALID_PERMIT_DOMAIN",
    PermitNotFound = "PERMIT_NOT_FOUND",
    CannotRemoveLastPermit = "CANNOT_REMOVE_LAST_PERMIT",
    AccountUninitialized = "ACCOUNT_UNINITIALIZED",
    ChainIdUninitialized = "CHAIN_ID_UNINITIALIZED",
    FheKeyNotFound = "FHE_KEY_NOT_FOUND",
    CrsNotFound = "CRS_NOT_FOUND",
    ProviderNotInitialized = "PROVIDER_NOT_INITIALIZED",
    SignerNotInitialized = "SIGNER_NOT_INITIALIZED",
    SealOutputFailed = "SEAL_OUTPUT_FAILED",
    SealOutputReturnedNull = "SEAL_OUTPUT_RETURNED_NULL",
    InvalidUtype = "INVALID_UTYPE",
    DecryptFailed = "DECRYPT_FAILED",
    DecryptReturnedNull = "DECRYPT_RETURNED_NULL",
    ZkVerifyInsertPackedCtHashesFailed = "ZK_VERIFY_INSERT_PACKED_CT_HASHES_FAILED",
    ZkVerifySignFailed = "ZK_VERIFY_SIGN_FAILED",
    ZkVerifyFailed = "ZK_VERIFY_FAILED",
    EncryptRemainingInItems = "ENCRYPT_REMAINING_IN_ITEMS"
}
declare class CofhejsError extends Error {
    readonly code: CofhejsErrorCode;
    readonly cause?: Error;
    constructor({ code, message, cause, }: {
        code: CofhejsErrorCode;
        message: string;
        cause?: Error;
    });
    serialize(): string;
}
type Result<T> = {
    success: true;
    data: T;
    error: null;
} | {
    success: false;
    data: null;
    error: CofhejsError;
};
declare const ResultErr: <T>(error: CofhejsError) => Result<T>;
declare const ResultOk: <T>(data: T) => Result<T>;
declare const isCofhejsError: (error: unknown) => error is CofhejsError;
declare const ResultErrOrInternal: <T>(error: unknown) => Result<T>;
declare function wrapFunction<Args extends any[], R>(fn: (...args: Args) => R): (...args: Args) => Result<R>;
declare function wrapFunctionAsync<Args extends any[], R>(fn: (...args: Args) => Promise<R>): (...args: Args) => Promise<Result<R>>;
declare const ResultHttpError: (error: unknown, url: string, status?: number) => CofhejsError;
declare const ResultValidationError: (message: string) => CofhejsError;

type UintFheTypes = (typeof FheUintUTypes)[number];
type UnsealedItem<U extends FheTypes> = U extends FheTypes.Bool ? boolean : U extends FheTypes.Uint160 ? string : U extends UintFheTypes ? bigint : never;

interface AbstractProvider {
    getChainId(): Promise<string>;
    call(tx: {
        to: string;
        data: string;
    }): Promise<string>;
    send(method: string, params: any[]): Promise<any>;
}
interface AbstractSigner {
    getAddress(): Promise<string>;
    signTypedData(domain: object, types: Record<string, Array<object>>, value: object): Promise<string>;
    provider: AbstractProvider;
    sendTransaction(tx: {
        to: string;
        data: string;
    }): Promise<string>;
}
type Environment = "MOCK" | "LOCAL" | "TESTNET" | "MAINNET";
type CofhejsMocksConfig = {
    decryptDelay?: number;
    zkvSigner?: AbstractSigner;
};
type InitializationParams = {
    provider: AbstractProvider;
    signer?: AbstractSigner;
    securityZones?: number[];
    coFheUrl?: string;
    verifierUrl?: string;
    thresholdNetworkUrl?: string;
    tfhePublicKeySerializer: (buff: Uint8Array) => void;
    compactPkeCrsSerializer: (buff: Uint8Array) => void;
    mockConfig?: CofhejsMocksConfig;
};

type VerifyResultRaw = {
    ct_hash: string;
    signature: string;
    recid: number;
};
type VerifyResult = {
    ct_hash: string;
    signature: string;
};

declare const SignatureTypes: {
    readonly PermissionedV2IssuerSelf: ("recipient" | "issuer" | "expiration" | "validatorId" | "validatorContract" | "sealingKey")[];
    readonly PermissionedV2IssuerShared: ("recipient" | "issuer" | "expiration" | "validatorId" | "validatorContract")[];
    readonly PermissionedV2Recipient: ("issuerSignature" | "sealingKey")[];
};
type PermitSignaturePrimaryType = keyof typeof SignatureTypes;
declare const getSignatureTypesAndMessage: <T extends "recipient" | "issuer" | "expiration" | "validatorId" | "validatorContract" | "issuerSignature" | "sealingKey">(primaryType: PermitSignaturePrimaryType, fields: T[] | readonly T[], values: Pick<Permission, T> & Partial<Permission>) => {
    types: EIP712Types;
    primaryType: string;
    message: EIP712Message;
};

declare class Permit implements PermitInterface, PermitMetadata {
    /**
     * Name for this permit, for organization and UI usage, not included in signature.
     */
    name: string;
    /**
     * The type of the Permit (self / sharing)
     * (self) Permit that will be signed and used by the issuer
     * (sharing) Permit that is signed by the issuer, but intended to be shared with recipient
     * (recipient) Permit that has been received, and signed by the recipient
     */
    type: "self" | "sharing" | "recipient";
    /**
     * (base) User that initially created the permission, target of data fetching
     */
    issuer: string;
    /**
     * (base) Expiration timestamp
     */
    expiration: number;
    /**
     * (sharing) The user that this permission will be shared with
     * ** optional, use `address(0)` to disable **
     */
    recipient: string;
    /**
     * (issuer defined validation) An id used to query a contract to check this permissions validity
     * ** optional, use `0` to disable **
     */
    validatorId: number;
    /**
     * (issuer defined validation) The contract to query to determine permission validity
     * ** optional, user `address(0)` to disable **
     */
    validatorContract: string;
    /**
     * (base) The publicKey of a sealingPair used to re-encrypt `issuer`s confidential data
     *   (non-sharing) Populated by `issuer`
     *   (sharing)     Populated by `recipient`
     */
    sealingPair: SealingKey;
    /**
     * (base) `signTypedData` signature created by `issuer`.
     * (base) Shared- and Self- permissions differ in signature format: (`sealingKey` absent in shared signature)
     *   (non-sharing) < issuer, expiration, recipient, validatorId, validatorContract, sealingKey >
     *   (sharing)     < issuer, expiration, recipient, validatorId, validatorContract >
     */
    issuerSignature: string;
    /**
     * (sharing) `signTypedData` signature created by `recipient` with format:
     * (sharing) < sealingKey, issuerSignature>
     * ** required for shared permits **
     */
    recipientSignature: string;
    /**
     * EIP712 domain used to sign this permit.
     * Should not be set manually, included in metadata as part of serialization flows.
     */
    _signedDomain: EIP712Domain | undefined;
    constructor(options: PermitInterface, metadata?: Partial<PermitMetadata>);
    static create(options: PermitOptions): Promise<Permit>;
    static createAndSign(options: PermitOptions, signer: AbstractSigner | undefined): Promise<Permit>;
    updateName: (name: string) => void;
    /**
     * Creates a `Permit` from a serialized permit, hydrating methods and classes
     *
     * @param {SerializedPermit} - Permit structure excluding classes
     * @returns {Permit} - New instance of Permit class
     */
    static deserialize: ({ _signedDomain, sealingPair, ...permit }: SerializedPermit) => Permit;
    static validate: (permit: Permit) => zod.SafeParseReturnType<{
        issuer: string;
        type: "self" | "sharing" | "recipient";
        sealingPair: {
            privateKey: string;
            publicKey: string;
        };
        recipient?: string | undefined;
        name?: string | undefined;
        expiration?: number | undefined;
        validatorId?: number | undefined;
        validatorContract?: string | undefined;
        issuerSignature?: string | undefined;
        recipientSignature?: string | undefined;
    }, {
        recipient: string;
        issuer: string;
        name: string;
        type: "self" | "sharing" | "recipient";
        expiration: number;
        validatorId: number;
        validatorContract: string;
        sealingPair: {
            privateKey: string;
            publicKey: string;
        };
        issuerSignature: string;
        recipientSignature: string;
    }>;
    /**
     * Utility to extract the public data from a permit.
     * Used in `serialize`, `getPermission`, `getHash` etc
     */
    getInterface: () => PermitInterface;
    /**
     * Export the necessary permit data to share a permit with another user
     */
    export: () => string;
    /**
     * Serializes the permit, removing classes and methods.
     */
    serialize: () => SerializedPermit;
    /**
     * Extracts a permission from this permit ready for use in the query decrypt/sealoutput flows.
     * The permission inherits most fields from the permit, however
     * `permit.sealingPair` is removed and replaced by `permit.sealingPair.publicKey` in the `sealingKey` field.
     * `permit.type` is removed, the type is determined on-chain by which populated fields are present.
     * `permit.name` is removed, the name is used only for organization and UI purposes.
     *
     * @permit {boolean} skipValidation - Flag to prevent running validation on the permit before returning the extracted permission. Used internally.
     * @returns {Permission}
     */
    getPermission: (skipValidation?: boolean) => Permission;
    /**
     * Returns a stable hash depending on the core data of the permit.
     * Is used in the store as each permit's key in the permit map.
     */
    getHash: () => string;
    /**
     * Returns the domain, types, primaryType, and message fields required to request the user's signature
     * Primary type is returned to allow viem clients to more easily connect
     */
    getSignatureParams: (primaryType: PermitSignaturePrimaryType) => {
        types: EIP712Types;
        primaryType: string;
        message: EIP712Message;
    };
    /**
     * Fetches the EIP712 domain for the given chainId.
     * If the domain is not found, it will be fetched from the EIP712 domain registry.
     *
     * @param {string} chainId - The chainId to fetch the EIP712 domain for
     * @param {AbstractProvider} provider - The provider to fetch the EIP712 domain from
     * @returns {EIP712Domain} - The EIP712 domain for the given chainId
     */
    fetchEIP712Domain: (provider: AbstractProvider) => Promise<EIP712Domain>;
    /**
     * Returns true if the permit's signed domain matches the provided domain.
     */
    matchesDomain: (domain: EIP712Domain) => boolean;
    /**
     * Fetches the EIP712 domain for the connected chain (`provider`)
     * Returns false if the domain doesn't match, or if the permit has no signed domain
     *
     * @param {AbstractProvider} provider - The provider to fetch the EIP712 domain from
     * @returns {boolean} - True if the domain matches, false otherwise
     */
    checkSignedDomainValid: (provider: AbstractProvider) => Promise<boolean>;
    /**
     * Determines the required signature type.
     * Creates the EIP712 types and message.
     * Prompts the user for their signature.
     * Inserts the signature into `issuerSignature` or `recipientSignature` as necessary.
     *
     * @param {AbstractSigner} signer - Signer responsible for signing the EIP712 permit signature, throws if undefined
     */
    sign: (signer: AbstractSigner | undefined) => Promise<void>;
    /**
     * Use the privateKey of `permit.sealingPair` to unseal `ciphertext` returned from the Fhenix chain.
     * Useful when not using `SealedItem` structs and need to unseal an individual ciphertext.
     */
    unseal: (ciphertext: EthEncryptedData) => bigint;
    /**
     * Returns whether the active party has created their signature.
     * If `permit.type` is self or sharing, the active party is `issuer`.
     * If `permit.type` is recipient, the active party is `recipient`
     *
     * @returns {boolean}
     */
    isSigned: () => boolean;
    /**
     * Returns whether this permit has expired due to `permit.expiration`
     *
     * @returns {boolean}
     */
    isExpired: () => boolean;
    /**
     * Overall validity checker of a permit, checks the signatures and expirations
     *
     * @returns {{valid: boolean, error: string}} - If `valid`, `error` is null, else `error` indicates which validity check failed
     */
    isValid: () => {
        readonly valid: false;
        readonly error: "expired";
    } | {
        readonly valid: false;
        readonly error: "not-signed";
    } | {
        readonly valid: true;
        readonly error: null;
    };
}

type ChainRecord<T> = Record<string, T>;
type AccountRecord<T> = Record<string, T>;
type HashRecord<T> = Record<string, T>;
type PermitsStore = {
    permits: ChainRecord<AccountRecord<HashRecord<SerializedPermit | undefined>>>;
    activePermitHash: ChainRecord<AccountRecord<string | undefined>>;
};
declare const permitStore: {
    store: Omit<zustand_vanilla.StoreApi<PermitsStore>, "persist"> & {
        persist: {
            setOptions: (options: Partial<zustand_middleware.PersistOptions<PermitsStore, {
                permits: {};
                activePermitHash: {};
            }>>) => void;
            clearStorage: () => void;
            rehydrate: () => void | Promise<void>;
            hasHydrated: () => boolean;
            onHydrate: (fn: (state: PermitsStore) => void) => () => void;
            onFinishHydration: (fn: (state: PermitsStore) => void) => () => void;
            getOptions: () => Partial<zustand_middleware.PersistOptions<PermitsStore, {
                permits: {};
                activePermitHash: {};
            }>>;
        };
    };
    getPermit: (chainId: string | undefined, account: string | undefined, hash: string | undefined) => Permit | undefined;
    getActivePermit: (chainId: string | undefined, account: string | undefined) => Permit | undefined;
    getPermits: (chainId: string | undefined, account: string | undefined) => Record<string, Permit>;
    setPermit: (chainId: string, account: string, permit: Permit) => void;
    removePermit: (chainId: string, account: string, hash: string, force?: boolean) => void;
    getActivePermitHash: (chainId: string | undefined, account: string | undefined) => string | undefined;
    setActivePermitHash: (chainId: string, account: string, hash: string) => void;
    removeActivePermitHash: (chainId: string, account: string) => void;
};

/**
 * Validator for the params used when creating a fresh Permit
 * Has defaults added that will be populated in the options object
 * Signatures superRefinement checks only the recipient, sealingPair and signatures are not necessary in the Permit params
 */
declare const PermitParamsValidator: z.ZodEffects<z.ZodEffects<z.ZodObject<{
    name: z.ZodDefault<z.ZodOptional<z.ZodString>>;
    type: z.ZodEnum<["self", "sharing", "recipient"]>;
    issuer: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>;
    expiration: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    recipient: z.ZodEffects<z.ZodDefault<z.ZodOptional<z.ZodString>>, string, string | undefined>;
    validatorId: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    validatorContract: z.ZodEffects<z.ZodDefault<z.ZodOptional<z.ZodString>>, string, string | undefined>;
    sealingPair: z.ZodOptional<z.ZodObject<{
        privateKey: z.ZodString;
        publicKey: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        privateKey: string;
        publicKey: string;
    }, {
        privateKey: string;
        publicKey: string;
    }>>;
    issuerSignature: z.ZodDefault<z.ZodOptional<z.ZodString>>;
    recipientSignature: z.ZodDefault<z.ZodOptional<z.ZodString>>;
}, "strip", z.ZodTypeAny, {
    recipient: string;
    issuer: string;
    name: string;
    type: "self" | "sharing" | "recipient";
    expiration: number;
    validatorId: number;
    validatorContract: string;
    issuerSignature: string;
    recipientSignature: string;
    sealingPair?: {
        privateKey: string;
        publicKey: string;
    } | undefined;
}, {
    issuer: string;
    type: "self" | "sharing" | "recipient";
    recipient?: string | undefined;
    name?: string | undefined;
    expiration?: number | undefined;
    validatorId?: number | undefined;
    validatorContract?: string | undefined;
    sealingPair?: {
        privateKey: string;
        publicKey: string;
    } | undefined;
    issuerSignature?: string | undefined;
    recipientSignature?: string | undefined;
}>, {
    recipient: string;
    issuer: string;
    name: string;
    type: "self" | "sharing" | "recipient";
    expiration: number;
    validatorId: number;
    validatorContract: string;
    issuerSignature: string;
    recipientSignature: string;
    sealingPair?: {
        privateKey: string;
        publicKey: string;
    } | undefined;
}, {
    issuer: string;
    type: "self" | "sharing" | "recipient";
    recipient?: string | undefined;
    name?: string | undefined;
    expiration?: number | undefined;
    validatorId?: number | undefined;
    validatorContract?: string | undefined;
    sealingPair?: {
        privateKey: string;
        publicKey: string;
    } | undefined;
    issuerSignature?: string | undefined;
    recipientSignature?: string | undefined;
}>, {
    recipient: string;
    issuer: string;
    name: string;
    type: "self" | "sharing" | "recipient";
    expiration: number;
    validatorId: number;
    validatorContract: string;
    issuerSignature: string;
    recipientSignature: string;
    sealingPair?: {
        privateKey: string;
        publicKey: string;
    } | undefined;
}, {
    issuer: string;
    type: "self" | "sharing" | "recipient";
    recipient?: string | undefined;
    name?: string | undefined;
    expiration?: number | undefined;
    validatorId?: number | undefined;
    validatorContract?: string | undefined;
    sealingPair?: {
        privateKey: string;
        publicKey: string;
    } | undefined;
    issuerSignature?: string | undefined;
    recipientSignature?: string | undefined;
}>;
/**
 * Validator for a Permit that is expected to be fully formed
 * Does not allow optional values or offer defaults
 * Validates that the correct signatures are populated
 * Validates sealingPair is populated
 */
declare const FullyFormedPermitValidator: z.ZodEffects<z.ZodEffects<z.ZodObject<{
    name: z.ZodDefault<z.ZodOptional<z.ZodString>>;
    type: z.ZodEnum<["self", "sharing", "recipient"]>;
    issuer: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>;
    expiration: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    recipient: z.ZodEffects<z.ZodDefault<z.ZodOptional<z.ZodString>>, string, string | undefined>;
    validatorId: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    validatorContract: z.ZodEffects<z.ZodDefault<z.ZodOptional<z.ZodString>>, string, string | undefined>;
    sealingPair: z.ZodObject<{
        privateKey: z.ZodString;
        publicKey: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        privateKey: string;
        publicKey: string;
    }, {
        privateKey: string;
        publicKey: string;
    }>;
    issuerSignature: z.ZodDefault<z.ZodOptional<z.ZodString>>;
    recipientSignature: z.ZodDefault<z.ZodOptional<z.ZodString>>;
}, "strip", z.ZodTypeAny, {
    recipient: string;
    issuer: string;
    name: string;
    type: "self" | "sharing" | "recipient";
    expiration: number;
    validatorId: number;
    validatorContract: string;
    sealingPair: {
        privateKey: string;
        publicKey: string;
    };
    issuerSignature: string;
    recipientSignature: string;
}, {
    issuer: string;
    type: "self" | "sharing" | "recipient";
    sealingPair: {
        privateKey: string;
        publicKey: string;
    };
    recipient?: string | undefined;
    name?: string | undefined;
    expiration?: number | undefined;
    validatorId?: number | undefined;
    validatorContract?: string | undefined;
    issuerSignature?: string | undefined;
    recipientSignature?: string | undefined;
}>, {
    recipient: string;
    issuer: string;
    name: string;
    type: "self" | "sharing" | "recipient";
    expiration: number;
    validatorId: number;
    validatorContract: string;
    sealingPair: {
        privateKey: string;
        publicKey: string;
    };
    issuerSignature: string;
    recipientSignature: string;
}, {
    issuer: string;
    type: "self" | "sharing" | "recipient";
    sealingPair: {
        privateKey: string;
        publicKey: string;
    };
    recipient?: string | undefined;
    name?: string | undefined;
    expiration?: number | undefined;
    validatorId?: number | undefined;
    validatorContract?: string | undefined;
    issuerSignature?: string | undefined;
    recipientSignature?: string | undefined;
}>, {
    recipient: string;
    issuer: string;
    name: string;
    type: "self" | "sharing" | "recipient";
    expiration: number;
    validatorId: number;
    validatorContract: string;
    sealingPair: {
        privateKey: string;
        publicKey: string;
    };
    issuerSignature: string;
    recipientSignature: string;
}, {
    issuer: string;
    type: "self" | "sharing" | "recipient";
    sealingPair: {
        privateKey: string;
        publicKey: string;
    };
    recipient?: string | undefined;
    name?: string | undefined;
    expiration?: number | undefined;
    validatorId?: number | undefined;
    validatorContract?: string | undefined;
    issuerSignature?: string | undefined;
    recipientSignature?: string | undefined;
}>;

declare const createTfheKeypair: () => {
    clientKey: TfheClientKey;
    publicKey: TfheCompactPublicKey;
};
declare const createTfhePublicKey: () => string;

type SdkStoreProviderInitialization = {
    providerInitialized: false;
    signer: never;
    account: never;
} | {
    providerInitialized: true;
    provider: AbstractProvider;
    chainId: string;
};
type SdkStoreSignerInitialization = {
    signerInitialized: false;
    signer: never;
    account: never;
} | {
    signerInitialized: true;
    signer: AbstractSigner;
    account: string;
};
type SdkStore = SdkStoreProviderInitialization & SdkStoreSignerInitialization & {
    provider: AbstractProvider;
    chainId: string;
    isTestnet: boolean;
    fheKeysInitialized: boolean;
    securityZones: number[];
    coFheUrl: string | undefined;
    verifierUrl: string | undefined;
    thresholdNetworkUrl: string | undefined;
    mockConfig: {
        decryptDelay: number;
        zkvSigner: AbstractSigner | undefined;
    };
};

type ViemInitializerParams = Omit<InitializationParams, "tfhePublicKeySerializer" | "compactPkeCrsSerializer" | "provider" | "signer" | "mockConfig"> & {
    ignoreErrors?: boolean;
    generatePermit?: boolean;
    environment?: Environment;
    viemClient: any;
    viemWalletClient?: any;
    mockConfig?: {
        decryptDelay?: number;
        zkvSigner?: any;
    };
};
type EthersInitializerParams = Omit<InitializationParams, "tfhePublicKeySerializer" | "compactPkeCrsSerializer" | "provider" | "signer"> & {
    generatePermit?: boolean;
    ethersProvider: any;
    ethersSigner?: any;
    environment?: Environment;
    mockConfig?: {
        decryptDelay?: number;
        zkvSigner?: any;
    };
};

/**
 * Initializes the `cofhejs` to enable encrypting input data, creating permits / permissions, and decrypting sealed outputs.
 * Initializes `fhevm` client FHE wasm module and fetches the provided chain's FHE publicKey.
 * If a valid signer is provided, a `permit/permission` is generated automatically
 */
declare const initialize: (params: Omit<InitializationParams, "tfhePublicKeySerializer" | "compactPkeCrsSerializer"> & {
    ignoreErrors?: boolean;
    generatePermit?: boolean;
    environment?: Environment;
}) => Promise<Permit | undefined>;
declare function encrypt<T extends any[]>(item: [...T], setStateCallback?: (state: EncryptStep) => void): Promise<Result<[...Encrypted_Inputs<T>]>>;
declare function encrypt<T extends any[]>(item: [...T], securityZone: number, setStateCallback?: (state: EncryptStep) => void): Promise<Result<[...Encrypted_Inputs<T>]>>;
declare const cofhejs: {
    store: zustand_vanilla.StoreApi<SdkStore>;
    initialize: (params: Omit<InitializationParams, "tfhePublicKeySerializer" | "compactPkeCrsSerializer"> & {
        ignoreErrors?: boolean | undefined;
        generatePermit?: boolean | undefined;
        environment?: Environment | undefined;
    }) => Promise<Result<Permit | undefined>>;
    initializeWithViem: (params: ViemInitializerParams) => Promise<Result<Permit | undefined>>;
    initializeWithEthers: (params: EthersInitializerParams) => Promise<Result<Permit | undefined>>;
    createPermit: (options?: PermitOptions | undefined) => Promise<Result<Permit>>;
    removePermit: (hash: string, force?: boolean | undefined) => Result<string>;
    importPermit: (imported: string | PermitInterface) => Promise<Result<Permit>>;
    selectActivePermit: (hash: string) => Result<Permit>;
    getPermit: (hash?: string | undefined) => Result<Permit>;
    getPermission: (hash?: string) => Result<Permission>;
    getAllPermits: () => Result<Record<string, Permit>>;
    encrypt: typeof encrypt;
    unseal: <U extends FheTypes>(ctHash: bigint, utype: U, account?: string | undefined, permitHash?: string | undefined) => Promise<Result<UnsealedItem<U>>>;
    decrypt: <U_1 extends FheTypes>(ctHash: bigint, utype: U_1, account?: string | undefined, permitHash?: string | undefined) => Promise<Result<UnsealedItem<U_1>>>;
};

export { type AbstractProvider, type AbstractSigner, type CoFheInAddress, type CoFheInBool, type CoFheInItem, type CoFheInUint128, type CoFheInUint16, type CoFheInUint256, type CoFheInUint32, type CoFheInUint64, type CoFheInUint8, CofhejsError, CofhejsErrorCode, type CofhejsMocksConfig, type EIP712, type EIP712Domain, type EIP712Message, type EIP712Type, type EIP712Types, type EncryptSetStateFn, EncryptStep, Encryptable, type EncryptableAddress, type EncryptableBool, type EncryptableItem, type EncryptableUint128, type EncryptableUint16, type EncryptableUint256, type EncryptableUint32, type EncryptableUint64, type EncryptableUint8, type Encryptable_CoFheInItem_Map, type EncryptedNumber, type Encrypted_Inputs, type Environment, type Expand, FheAllUTypes, FheTypes, FheUintUTypes, FullyFormedPermitValidator, GenerateSealingKey, type InitializationParams, type Permission, Permit, type PermitCore, type PermitInterface, type PermitMetadata, type PermitOptions, PermitParamsValidator, type PickPartial, type Result, ResultErr, ResultErrOrInternal, ResultHttpError, ResultOk, ResultValidationError, SealingKey, type SerializedPermit, SignatureTypes, type UintFheTypes, type UnsealedItem, type VerifyResult, type VerifyResultRaw, cofhejs, createTfheKeypair, createTfhePublicKey, getSignatureTypesAndMessage, initialize, isCofhejsError, isEncryptableItem, permitStore, wrapFunction, wrapFunctionAsync };
